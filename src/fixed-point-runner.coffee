define [
  'underscore'
  'jquery'
], (_, $) ->


  # Like a less.tree.Anonymous node but explicitly saying it contains a jQuery set.
  # created by move-to and used by `content: `
  class ArrayTreeNode
    constructor: (@values) ->
    eval: () -> @

  return class FixedPointRunner
    # plugins: []
    # $root: jQuery(...)
    # autogenClasses: {}
    # functions: {}
    # rules: {}

    constructor: (@$root, @plugins, @autogenClasses) ->
      @squirreledEnv = {} # id -> env map. Needs to persist across runs because the target may occur **after** the element that looks it up
      @functions = {}
      @rules = {}

      for plugin in @plugins
        @functions[funcName] = func for funcName, func of plugin.functions
        @rules[ruleName] = ruleFunc for ruleName, ruleFunc of plugin.rules


    lookupAutogenClass: ($node) ->
      classes = $node.attr('class').split(' ')
      foundClass = null
      for cls in classes
        if /^js-polyfill-autoclass-/.test(cls)
          console.error 'BUG: Multiple autogen classes. Canonicalize first!' if foundClass and @autogenClasses[cls]

          foundClass ?= @autogenClasses[cls]

      console.error 'Did not find autogenerated class in autoClasses' if not foundClass
      return foundClass


    # checks that valNode is non-null and none of the values are less.tree.Call
    # If they are in fact all values then it returns an array of strings-or-$els
    evaluateValNode: (valNode) ->
      ret = []
      if valNode instanceof less.tree.Expression
        vals = valNode.value
      else
        vals = [valNode]

      for val in vals
        if val instanceof less.tree.Quoted
          ret.push(val.value)
        else if val instanceof less.tree.Dimension
          # Counters return a Number (less.tree.Dimension)
          ret.push(val.value)
        else if val instanceof ArrayTreeNode
          # Append the elements in order
          for $el in val.values
            ret.push($el)
        else if val instanceof less.tree.Call
          console.log("Not finished evaluating yet: #{val.name}")
          return null
        else
          console.warn("ERROR: Pushing something unknown. [#{val.value}]")
          ret.push(val.value)
      return ret


    tick: ($interesting) ->
      somethingChanged = false
      # env is a LessEnv (passed to `lessNode.eval()`) so it needs to contain a .state and .helpers
      env =
        state: {} # plugins will add `counters`, `strings`, `buckets`, etc
        helpers:
          # $context: null
          interestingByHref: (href) =>
            console.error 'BUG: href must start with a # character' if '#' != href[0]
            id = href.substring(1)
            console.error 'BUG: id was not marked and squirreled before being looked up' if not @squirreledEnv[id]
            return @squirreledEnv[id]
          markInterestingByHref: (href) =>
            console.error 'BUG: href must start with a # character' if '#' != href[0]
            id = href.substring(1)
            wasAlreadyMarked = !! @squirreledEnv[id]
            if not wasAlreadyMarked
              somethingChanged = true
              # Mark that this node will need to squirrel its env
              @$root.find("##{id}").addClass('js-polyfill-interesting js-polyfill-target')
            return !wasAlreadyMarked

      for node in $interesting
        $node = $(node)

        env.helpers.$context = $node
        autogenRules = @lookupAutogenClass($node).rules
        for autogenRule in autogenRules
          ruleName = autogenRule.name
          ruleValNode = autogenRule.value

          # update the env
          @rules[ruleName]?(env, ruleValNode)

        if not $node.is('.js-polyfill-evaluated')
          # if the node has a `content:` rule then attempt to evaluate it
          for autogenRule in autogenRules
            if 'content' == autogenRule.name

              valNode = autogenRule.value.eval(env)
              # If valNode only contains values then all the function calls resolved
              # so update the contents of the node and mark it as `evaluated`
              values = @evaluateValNode(valNode)
              if values
                somethingChanged = true

                # Do not replace pseudo elements
                $pseudoEls = $node.children('.js-polyfill-pseudo')
                $pseudoBefore = $pseudoEls.not(':not(.js-polyfill-pseudo-before)')
                $pseudoRest = $pseudoEls.not($pseudoBefore)

                $node.empty()
                # Fill in the before pseudo elements
                $node.append($pseudoBefore)

                # Append 1-by-1 because they values may be multiple jQuery sets (like `content: pending(bucket1) pending(bucket2)`)
                for val in values
                  $node.append(val)

                # Fill in the rest of the pseudo elements
                $node.append($pseudoRest)

                $node.addClass('js-polyfill-evaluated')

        if $node.is('.js-polyfill-target')
          # Keep the helper functions (targetText uses them) but not the state
          targetEnv =
            helpers: _.clone(env.helpers)
            state: JSON.parse(JSON.stringify(env.state)) # Perform a deep clone
          targetEnv.helpers.$context = $node
          @squirreledEnv[$node.attr('id')] = targetEnv

      return somethingChanged


    setUp: () ->
      # Register all the functions with less.tree.functions
      for funcName, func of @functions
        # Wrap all the functions and attach them to `less.tree.functions`
        wrapper = (funcName, func) -> () ->
          ret = func.apply(@, [@env, arguments...])
          # If ret is null or undefined then ('' is OK) mark that is was not evaluated
          # by returning the original less.tree.Call
          if not ret?
            return new less.tree.Call(funcName, arguments)
          else if ret instanceof Array
            return new ArrayTreeNode(ret)
          else if _.isString(ret)
            # Just being a good LessCSS user. Could have just returned Anonymous
            return new less.tree.Quoted("'#{ret}'", ret)
          else if _.isNumber(ret)
            # Just being a good LessCSS user. Could have just returned Anonymous
            return new less.tree.Dimension(ret)
          else
            return new less.tree.Anonymous(ret)

        less.tree.functions[funcName] = wrapper(funcName, func)


    # Detach all the functions so `lessNode.toCSS()` will generate the CSS
    done: () ->
      for funcName of @functions
        delete less.tree.functions[funcName]
      # TODO: remove all `.js-polyfill-interesting, .js-polyfill-evaluated, .js-polyfill-target` classes

      discardedClasses = [
        'js-polyfill-evaluated'
        'js-polyfill-interesting'
        'js-polyfill-target'
      ]
      # add '.' and ',' for the find, but a space for the classes to remove
      @$root.find(".#{discardedClasses.join(',.')}").removeClass(discardedClasses.join(' '))

    run: () ->
      @setUp()

      # Initially, interesting nodes are all the nodes that have an AutogenClass
      $interesting = @$root.find('.js-polyfill-autoclass, .js-polyfill-interesting')
      $interesting.addClass('js-polyfill-interesting')

      while @tick($interesting) # keep looping while somethingChanged
        $interesting = @$root.find('.js-polyfill-interesting')

      @done()
